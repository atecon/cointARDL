include string_utils.gfn


function void Info (const string s)
    printf "\nInfo: %s\n", s
end function

function void Warning (const string s)
    printf "\nWarning: %s\n", s
end function

function void Error (const string s)
    printf "\nError: %s\n", s
end function


function bundle test_to_int_mapping (void)
    /*  Key-value mapping */
    return _(bdm = 1, pss = 2)
end function


function bundle case_to_int_mapping (void)
    /*  Key-value mapping */
    return _(urc = 1, rc = 2, rct = 3)
end function


function bundle bootstrap_to_int_mapping (void)
    /*  Key-value mapping */
    return _(parametric = 1,\
                non_parametric = 2,\
                wild_uniform = 3,\
                wild_rademacher = 4)
end function


function bundle default_values (void)
    /* Set default values here. */

    bundle B

    string B.name_test = "pss"           # früher 'whichTest'
    string B.name_case = "rc"            # früher 'case'
    scalar B.max_lag_length = 4              # früher 'pq'
    scalar B.conditional_model = TRUE    # früher 'condARDL'
    string B.name_bootstrap = "non_parametric" # früher 'btype'
    scalar B.bootstrap_replications = 199    # früher 'bootrep'
    scalar B.stopping_fraction = 0.2         # früher 'failstop'
    scalar B.verbose = FALSE             # früher 'verb'
    string B.estimator = "ols"

    return B
end function


function scalar check_case_and_trend (const bundle self)
    /* Check that  */

    if self.name_case == "rct" && self.with_linear_trend == FALSE
        Error("The case 'rct' requires that a time trend is included to the list of restricted exogenous.")
        return TRUE
    endif

    return FALSE
end function


function scalar check_case_and_intercept (const bundle self)
    /* Check that case */

    if (self.name_case == "rc" || self.name_case == "rct") && self.with_intercept == FALSE
        Error("The cases 'rc' or 'rct' require that an intercept is included to the list of restricted exogenous.")
        return TRUE
    endif

    return FALSE
end function


function scalar set_min_lag_length (const bundle self)
    /* Compute minimum lag-length. */

    return self.conditional_model == TRUE ? 0 : 1
end function


function string set_verbosity_string (const bundle self)
    /* Compile "quiet" string. */

    return (self.verbose == TRUE) ? "--quiet" : ""
end function


function scalar includes_intercept (const list L)
    /* Check whether L includes 'const' series. */
    return (inlist(L, "const") > 0) ? TRUE : FALSE
end function

function scalar includes_linear_trend (const list L)
    /* Check whether L includes 'time' series. */
    return (inlist(L, "time") > 0) ? TRUE : FALSE
end function


function bundle setModel (const series y "Endogenous",
                           const list xlist "List of exogenous regressors",
                           const list rxlist[null] "List of exogenous",
                           const bundle Parameters[null])
    bundle self
    self.error = FALSE
    if exists(Parameters)
        bundle self = Parameters
    endif
    self = self + default_values()

    scalar self.with_intercept = includes_intercept(rxlist)
    scalar self.with_linear_trend = includes_linear_trend(rxlist)
 
    self.error += check_case_and_trend(self)
    self.error += check_case_and_intercept(self)
    print self
    if self.error > 0
        return self
    endif

    self.min_lag_length = set_min_lag_length(self)
    self.verbose_string = set_verbosity_string(self)

    series self.y = y
    list self.xlist = xlist
    list self.rxlist = rxlist

    return self
end function


function bundle estimate_model (const bundle self)
    /* Run actual model estimation. Return model bundle. */

    bundle B

    series y = self.y
    list xlist = self.xlist
    list rxlist = self.rxlist
    string verbose_string = self.verbose_string

    if self.estimator == "ols"
        ols y y(-1 to -self.max_lag_length) xlist(self.min_lag_length to -self.max_lag_length) rxlist @verbose_string
    else
        Error(sprintf("Estimator '%s' is not supported.", self.estimator))
        return B
    endif

    return $model
end function


function scalar model_is_stable (const bundle Model)
    /* Check for dynamic stability. */

    /*
    1) Retrieve vector of AR coefficients:
        - read out Model.depvar
        - iterate through Model.parnames and search for indizes
        of strings starting with "y_"
        - selifr(Model.coeff, mask)
        - call arstabA()    


    scalar b.ay = b.addDET + 1
    scalar b.ey = b.ay+b.pq-1
    scalar err = 0
    arstabA($coeff[b.ay:b.ey],&err)
    */

    return 1
end function


function matrix get_ar_coefficients (const bundle Model)
    /* Retrieve vector of AR coefficients. */

    # scalar n_chars_depvar = nelem(Model.depvar)
    strings parnames = Model.parnames
    matrix ar_coeffs = {}
    string starts_with = sprintf("%s_", Model.depvar) # e.g. 'y_<LAG>'
    loop foreach i parnames
        if strprefix("$i", starts_with)
            ar_coeffs |= Model.coeff[i]
        endif
    endloop

    return (nelem(ar_coeffs) == 0) ? {0} : ar_coeffs
end function


function scalar estimateModel (bundle *self "Bundel from setModel()")
    /* Estimate model and compute cointegration results. 
    Return TRUE in case of an error, otherwise FALSE. */

    Model = estimate_model(self)
    if nelem(Model) == 0
        return TRUE
    endif
    
    print Model
    scalar is_stable = model_is_stable(Model)

    return FALSE
end function















