include string_utils.gfn
# TODO: Make use of new logging functionalities

function void Info (const string s)
    printf "\nInfo: %s\n", s
end function

function void Warning (const string s)
    printf "\nWarning: %s\n", s
end function

function void Error (const string s)
    printf "\nError: %s\n", s
end function


function bundle test_to_int_mapping (void)
    /*  Key-value mapping */
    return _(bdm = 1, pss = 2)
end function


function bundle case_to_int_mapping (void)
    /*  Key-value mapping */
    return _(urc = 1, rc = 2, rct = 3)
end function


function bundle bootstrap_to_int_mapping (void)
    /*  Key-value mapping */
    return _(parametric = 1,\
                non_parametric = 2,\
                wild_uniform = 3,\
                wild_rademacher = 4)
end function


function bundle default_values (void)
    /* Set default values here. */

    bundle B

    string B.name_test = "bdm"           # früher 'whichTest'
    string B.name_case = "rc"            # früher 'case'
    scalar B.max_lag_length = 4              # früher 'pq'
    scalar B.conditional_model = TRUE    # früher 'condARDL'
    string B.name_bootstrap = "non_parametric" # früher 'btype'
    scalar B.bootstrap_replications = 199    # früher 'bootrep'
    scalar B.stopping_fraction = 0.2         # früher 'failstop'
    scalar B.verbose = FALSE             # früher 'verb'
    string B.estimator = "ols"
    scalar B.stability_threshold = -0.00001

    return B
end function


function scalar check_case_and_trend (const bundle self)
    /* Check that  */

    if self.name_case == "rct" && self.with_linear_trend == FALSE
        Error("The case 'rct' requires that a time trend is included to the list of restricted exogenous.")
        return TRUE
    endif

    return FALSE
end function


function scalar check_case_and_intercept (const bundle self)
    /* Check that case */

    if (self.name_case == "rc" || self.name_case == "rct") && self.with_intercept == FALSE
        Error("The cases 'rc' or 'rct' require that an intercept is included to the list of restricted exogenous.")
        return TRUE
    endif

    return FALSE
end function


function scalar set_min_lag_length (const bundle self)
    /* Compute minimum lag-length. */

    return self.conditional_model == TRUE ? 0 : 1
end function


function string set_verbosity_string (const bundle self)
    /* Compile "quiet" string. */

    return (self.verbose == TRUE) ? "--quiet" : ""
end function


function scalar includes_intercept (const list L)
    /* Check whether L includes 'const' series. */
    return (inlist(L, "const") > 0) ? TRUE : FALSE
end function

function scalar includes_linear_trend (const list L)
    /* Check whether L includes 'time' series. */
    return (inlist(L, "time") > 0) ? TRUE : FALSE
end function


function bundle setModel (const series y "Endogenous",
                          const list xlist "List of exogenous regressors",
                          const list rxlist[null] "List of exogenous",
                          const bundle Parameters[null])
    bundle self
    self.error = FALSE
    if exists(Parameters)
        bundle self = Parameters
    endif
    self = self + default_values()

    scalar self.with_intercept = includes_intercept(rxlist)
    scalar self.with_linear_trend = includes_linear_trend(rxlist)

    self.error += check_case_and_trend(self)
    self.error += check_case_and_intercept(self)
    if self.error > 0
        return self
    endif

    self.min_lag_length = set_min_lag_length(self)
    self.verbose_string = set_verbosity_string(self)

    series self.y = y
    list self.xlist = xlist
    list self.rxlist = rxlist

    return self
end function


function bundle estimate_model (const bundle self)
    /* Run actual model estimation. Return model bundle. */

    bundle B

    series y = self.y
    list xlist = self.xlist
    list rxlist = self.rxlist
    string verbose_string = self.verbose_string

    if self.estimator == "ols"
        catch ols y y(-1 to -self.max_lag_length) xlist(self.min_lag_length to -self.max_lag_length) rxlist @verbose_string
    else
        Error(sprintf("Estimator '%s' is not supported.", self.estimator))
        return B
    endif

    if $error
        Error("Model estimation failed.")
        return B
    endif

    B = $model
    if self.estimator == "ols"
        B.uhat = $uhat
    endif


    # Test the null of no long-run relationship
    if self.name_test == "pss"


    elif self.name_test == "bdm"

    endif



    return B
end function


function matrix strstarts_array (const strings sarr, const string starts_with)
    /* Generalization of the string_utils' function strstarts() for arrays. Returns a boolean mask vector for strings that start with 'starts-with'. */

    if nelem(sarr) == 0
        Warning("String array is empty.")
        return {0}
    endif

    matrix mask = mshape(NA, nelem(sarr), 1)
    loop foreach i sarr
        mask[i] = strstarts(sarr[i], starts_with)
    endloop

    return mask
end function


function scalar model_is_stable (const bundle Model, const scalar stability_threshold)
    /* Check for dynamic stability. */

    # Search for <nameEndogenous_*> e.g. y_1, y_2 etc.
    string starts_with = sprintf("%s_", Model.depvar)
    matrix ar_coeff = get_vector_values_by_name(Model.coeff,\
                                                Model.parnames,
                                                starts_with)

    if (sum(ar_coeff) - 1) > stability_threshold
        Error("The specified model is dynamically unstable.")
        return FALSE
    else
        return TRUE
    endif
end function


function matrix get_vector_values_by_name (matrix coeff "Column vector",
                                           const strings names "Names of 'coeff' entries",
                                           const string starts_with "Search for 'names' that start with it")
    /* Retrieve from 'coeff' the vector of coefficients whose i-th 'names' entry starts with 'starts_with'. */

    coeff = vec(coeff)
    errorif(nelem(names) != nelem(coeff), "Dimension mismatch.")

    matrix mask = strstarts_array(names, starts_with)
    coeff_selected = selifr(coeff, mask)

    return (nelem(coeff_selected) == 0) ? {0} : coeff_selected
end function


function bundle map_n_deterministics (void)
    /* Map for each case the number of deterministics */

    return _(urc = 0, rc = 1, rct = 2)
end function


function matrix initialize_Rmat_bdm (const int n_arcoeffs[1::],
                                 const int n_coeffs[1::],
                                 const string name_case)
    /* Initialize restriction matrix. */
    scalar nd = map_n_deterministics()[name_case]
    # TODO: Do we restrict all AR coeffs. or only "lag 1" (==y(-1))?
    scalar nrows = n_arcoeffs + nd
    # scalar nrows = 1 + nd       # As implemented in old version

    return zeros(nrows, n_coeffs)
end function


function bundle Rq_matrices_bdm (const bundle Model,
                                  const bundle self)
    /* Prepare R matrix and q vector for BDM-based Wald test. */

    # restrict AR coefficients for testing 'rho=0'
    string starts_with = sprintf("%s_", Model.depvar)
    mask = strstarts_array(Model.parnames, starts_with)
    matrix positions_ar_coeffs = selifr(seq(1, rows(mask))', mask)

    matrix Rmat = initialize_Rmat_bdm(rows(positions_ar_coeffs),\
                                      rows(Model.coeff),\
                                      self.name_case)

    scalar pos_const = imaxc(strstarts_array(Model.parnames, "const"))
    scalar pos_time = imaxc(strstarts_array(Model.parnames,\
                                            "time"))
    scalar n_deter = map_n_deterministics()[self.name_case]

    matrix qvec = {}
    if self.name_case == "rc"
        Rmat[pos_const, pos_const] = 1
    elif self.name_case == "rct"
        Rmat[pos_const, pos_const] = 1
        Rmat[pos_time, pos_time] = 1
    endif

    if self.name_case != "urc"
        matrix qvec = zeros(n_deter, 1)
    endif
     # H0: Sum of AR-coeffs. is zero
    qvec |= ones(rows(positions_ar_coeffs))

    loop i=1..rows(positions_ar_coeffs)
        Rmat[(n_deter + i), positions_ar_coeffs[i]] = 1
    endloop

    # FIXME: Make sure Rmat and qvec have the right ordering in case of "rct"! Set of restrictions must match

    return _(Rmat, qvec)
end function


function bundle Rq_matrices_pss (const bundle Model,
                                 const bundle self,
                                 bundle *Rmat "already incl. BDM restrictions")
    /* Prepare R matrix and q vector for PSS-based Wald test. */

    /* OLD
    Rmat[(1+b.case), b.ay:b.ey]=1           # for rho
    scalar ax = b.ey+1
    scalar ex = ax+(b.condARDL + b.pq)-1
    loop i=(2+b.case)..(1+b.case+b.nx) -q
        Rmat[i,ax:ex] = 1        # Sum coefficients up
        ax = ex+1
        ex = ax+(b.condARDL + b.pq)-1
    endloop

    b.qvec = qvec
    b.Rmat = Rmat
    */

    bundle B = null

    return B
end function


function bundle prepare_Rq (const bundle Model,
                            const bundle self)
    /* Preparation for R matrix and q vector for linear Wald test on cointegration. */

    bundle Rq = Rq_matrices_bdm(Model, self)

    if self.name_test == "pss"
        funcerr("Not implemented, yet")
        # Rq_matrices_pss(Model, self, &Rq)
    endif

    return Rq
end function






function scalar estimateModel (bundle *self "Bundel from setModel()")
    /* Estimate model and compute cointegration results.
    Return TRUE in case of an error, otherwise FALSE. */

    Model = estimate_model(self)
    if nelem(Model) == 0
        sels.error = TRUE   # FIXME: Return self and check for error in calling function
        return TRUE
    endif

    scalar is_stable = model_is_stable(Model, self.stability_threshold)
    if !is_stable
        sels.error = TRUE
        return TRUE
    endif


    bundle Rq = prepare_Rq(Model, self)

    bundle WaldTest = wald_test(Model.coeff, Model.vcv, Rq.Rmat,\
                                Rq.qvec)


    # Next todos
    # Information of the null model for bootstrap
    1) Estimate the null model by OLS
    2) Extract coefficients
    3)
    /*
    matrix rARcoef = $coeff[b.ay:b.ey]      # AR coefficients
    b.rARcoef = rARcoef
    scalar b.ax = b.ey + 1
    if b.addDET > 0
        b.Zcoef = $coeff[1:(b.ay-1)] | $coeff[b.ax:]    # Deterministics + DL coeff needed for ysim()
    else
        b.Zcoef = $coeff[b.ax:]
    endif
    scalar b.ex = b.ax + b.nx*(b.condARDL + b.pq) - 1
    */


    return FALSE
end function


function bundle wald_test (const matrix coeff "point estimates",
                           const matrix vcv "estimated vcv",
                           const matrix Rmat "Specification of which exclusions to test",
                           const matrix qvec "Joint hypotheses to test")
    /* Linear Wald test. Return test statistics. */

    matrix outside = Rmat * coeff - qvec
    matrix inside = qform(Rmat, vcv)

    scalar test_stat = qform(outside', inv(inside))
    scalar p_value = pvalue(X, rows(qvec), test_stat)

    return _(test_stat, p_value)
end function



