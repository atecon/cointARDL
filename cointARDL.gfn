<?xml version="1.0" encoding="UTF-8"?>
<gretl-functions>
<gretl-function-package name="cointARDL" needs-time-series-data="true" minver="2016d" lives-in-subdir="true">
<author email="atecon@cryptolab.net">Artur Tarassow</author>
<version>0.7</version>
<date>2018-12-26</date>
<description>Bootstrap single-eq. cointegration tests</description>
<tags>C12 C20</tags>
<help>
pdfdoc:cointARDL.pdf
</help>
<gretl-function name="setMod" type="bundle">
 <params count="11">
  <param name="whichTest" type="int" min="0" max="1">
<description>Test type</description>
<labels count="2">
"BDM" "PSS" </labels>
  </param>
  <param name="case" type="int" min="0" max="2" default="1">
<description>Case</description>
<labels count="3">
"Unrestr. intercept" "restr. interc." "restr. interc.+trend" </labels>
  </param>
  <param name="Y" type="series" const="true">
<description>Endogenous</description>
  </param>
  <param name="xlist" type="list" const="true">
<description>List of exogenous regressors</description>
  </param>
  <param name="rxlist" type="list" optional="true" const="true">
<description>List of exogenous (no lags will be incl.)</description>
  </param>
  <param name="pq" type="int" min="1" default="4">
<description>Lag length in levels</description>
  </param>
  <param name="condARDL" type="bool" default="1">
<description>Conditional model: 0=No, 1=Yes (default)</description>
  </param>
  <param name="btype" type="int" min="0" max="4" default="1">
<description>Type of bootstrap</description>
<labels count="5">
"0=parametric" "1=non-parametric" "2=wild uniform" "3=wild Rademacher" "4=block-boots." </labels>
  </param>
  <param name="bootrep" type="int" min="99" default="999"/>
  <param name="failstop" type="scalar" min="0.01" max="0.9" default="0.2">
<description>Fraction of failed bootstrap iterations before full stop</description>
  </param>
  <param name="verb" type="bool" default="1">
<description>Print details 0:No, 1:Yes</description>
  </param>
 </params>
<code>bundle b
if case==2 &amp;&amp; strstr(varname(rxlist), &quot;time&quot;)==&quot;&quot;
  printf &quot;\n*** You've chosen to run case 2 but no time trend is provided in rxlist. ***\n&quot;
  funcerr &quot;*** Please re-specify your model. ***&quot;
endif
scalar b.addDET = 0
if inlist(rxlist, &quot;const&quot;)
  scalar b.addDET = 1
  rxlist -= const
endif
if inlist(rxlist, &quot;time&quot;)
  scalar b.addDET = 2
  rxlist -= rxlist.time
endif
matrix b.my = {Y}
matrix b.mx = xlist
matrix b.mrx = rxlist
b.nx = nelem(xlist)
b.nrx = nelem(rxlist)
b.pq = pq
b.condARDL = condARDL
if b.condARDL
  b.pqmin = 0
else
  b.pqmin = -1
endif
b.whichTest = whichTest
b.case = case
b.btype = btype
b.bootrep = bootrep
b.failstop = failstop
string b.optsil = (verb==1) ? &quot;&quot; : &quot;--quiet&quot;
return b
</code>
</gretl-function>
<gretl-function name="runCoint" type="void">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>series Y = b.my
list xlist = b.mx
list rxlist = b.mrx
lags Y xlist
quiet = b.optsil
# TODO: In principle we could provide an user-defined matrix before calling runARDL()
# This could be helpful if want to provide a gappy coefficient matrix with some
# zeros or fixed parameters (for whetever reasons).
list lDET = null
if b.addDET==1
  list lDET += const
elif b.addDET==2
  list lDET += const time
endif
matrix b.md = lDET
ols Y lDET Y(-1 to -b.pq) xlist(b.pqmin to -b.pq) rxlist --quiet #@quiet
# Evaluate stability first
scalar b.ay = b.addDET + 1
scalar b.ey = b.ay+b.pq-1
scalar err = 0
arstabA($coeff[b.ay:b.ey],&amp;err)
scalar cancel = 0
if err
  printf &quot;*** NOTE: Your model is unstable. ***\n&quot;
  printf &quot;*** Please re-specify and try again. ***\n&quot;
  cancel=1
endif
if cancel==0
  b.uhat = {$uhat}			# those are used for resampling
  scalar b.nx = nelem(xlist)
  scalar b.nall = nelem($coeff)
  #------------------------------------------
  # Test the null of no long-run relationship
  #------------------------------------------
  prepRq(&amp;b)
  matrix Rmat = b.Rmat
  matrix qvec = b.qvec
  restrict --full --silent#@quiet		 # H0: SUM(a_j)-1=0 --&gt; in ECM: rho=0
    R = Rmat
    q = qvec
  end restrict
  b.teststat = $test				# F-Test stats.
  # Information of the null model for bootstrap
  matrix rARcoef = $coeff[b.ay:b.ey]		# AR coefficients
  b.rARcoef = rARcoef
  scalar b.ax = b.ey + 1
  if b.addDET &gt; 0
    b.Zcoef = $coeff[1:(b.ay-1)] | $coeff[b.ax:]	# Deterministics + DL coeff needed for ysim()
  else
    b.Zcoef = $coeff[b.ax:]
  endif
  scalar b.ex = b.ax + b.nx*(b.condARDL + b.pq) - 1
  # Run bootstrap Test()
  bootTest(&amp;b)
  # Bootstrap p-value
  if b.cancel==0
    matstat = b.matstat
    b.crit =  quantile(b.matstat,{0.99, 0.95, 0.9})
    rownames(b.crit, &quot;99pct. 95pct. 90pct.&quot;)	# TODO: rnameset()
    b.pvboot = sum(abs(b.matstat).&gt;= abs(b.teststat))/b.bootrep	# Compute scalar bootstrap p-value
    # Print results
    if b.optsil == &quot;&quot;
      printTest(&amp;b)
    endif
  else
    matrix b.crit = NA
    matrix b.pvboot = NA
    matrix b.test = NA
  endif
else
  matrix b.crit = NA
  matrix b.pvboot = NA
  matrix b.test = NA
endif
</code>
</gretl-function>
<gretl-function name="prepRq" type="void" private="1">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code># BDM test
if b.whichTest==0
  matrix Rmat = zeros((1+b.case),b.nall)
  if b.case == 0
    matrix qvec = {1}
  elif b.case == 1
    Rmat[1,1] = 1			# restrict const
    matrix qvec = zeros(1,1) | {1}
  elif b.case == 2
    Rmat[1,1] = 1			# restrict const, unrestri. trend
    Rmat[2,2] = 1			# restrict trend
    matrix qvec = zeros(2,1) | {1}
  endif
  Rmat[(1+b.case),b.ay:b.ey] = 1		# restrict AR coefficients
  # PSS test
else
  if b.case==0
    matrix Rmat = zeros(1+b.nx,b.nall)	# unrestr. const.
    matrix qvec = {1} | zeros(b.nx,1)
  elif b.case==1
    matrix Rmat = zeros(2+b.nx,b.nall)	# restr. const
    Rmat[1,1] = 1
    matrix qvec = zeros(1,1) | {1} | zeros(b.nx,1)
  elif b.case==2
    matrix Rmat = zeros(3+b.nx,b.nall)	# restr. const + time
    Rmat[1,1] = 1
    Rmat[2,2] = 1
    matrix qvec = zeros(2,1) | {1} | zeros(b.nx,1)
  endif
  Rmat[(1+b.case), b.ay:b.ey]=1			# for rho
  scalar ax = b.ey+1
  scalar ex = ax+(b.condARDL + b.pq)-1
  loop i=(2+b.case)..(1+b.case+b.nx) -q
    Rmat[i,ax:ex] = 1		 # Sum coefficients up
    ax = ex+1
    ex = ax+(b.condARDL + b.pq)-1
  endloop
endif
b.qvec = qvec
b.Rmat = Rmat
</code>
</gretl-function>
<gretl-function name="printTest" type="void" private="1">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>printf &quot;\n*****************************************************\n&quot;
if b.whichTest==0
  printf &quot;*** BDM bootstrap t-Test based on ARDL(%d,%d) model ***\n&quot;, b.pq, b.pq
else
  printf &quot;*** PSS bootstrap F-Test based on ARDL(%d,%d) model ***\n&quot;, b.pq, b.pq
endif
printf &quot;*****************************************************\n&quot;
printf &quot;Restriction case:\n&quot;
if b.case==0
  printf &quot;Unrestricted constant\n&quot;
elif b.case==1
  printf &quot;Restricted constant\n&quot;
elif b.case==2
  printf &quot;Restricted constant and restricted trend\n&quot;
endif
printf &quot;Bootstrap type: &quot;
if b.btype==0
  string btype = &quot;parametric&quot;
elif b.btype==1
  string btype = &quot;non-parametric&quot;
elif b.btype==2
  string btype = &quot;wild (uniform)&quot;
elif b.btype==3
  string btype = &quot;wild (Rademacher)&quot;
elif b.btype==4
  string btype = &quot;block-bootstrap&quot;
endif
printf &quot;Bootstrap replications: %d\n&quot;, b.bootrep
printf &quot;\nInitial test statistics = %.3f\n&quot;, b.teststat
printf &quot;\nCritical values:\n       1pct.  \t 5pct.  \t 10pct.\n&quot;
printf &quot;%12.3f\n&quot;, b.crit'
printf &quot;Bootstrap p-value = %.3f\n&quot;, b.pvboot
printf &quot;Percentage of failed iterations = %.2f\n&quot;, 100*b.failed/b.bootrep
printf &quot;******************************************************\n&quot;
</code>
</gretl-function>
<gretl-function name="bootTest" type="void" private="1">
 <params count="1">
  <param name="b" type="bundleref"/>
 </params>
<code>matrix Rmat = b.Rmat
matrix qvec = b.qvec
series Y = b.my
list xlist = b.mx
list rxlist = b.mrx
list lDET = b.md
string quiet = b.optsil
lags Y xlist
list Z = lDET xlist(b.pqmin to -b.pq) rxlist
matrix Xbeta = b.Zcoef
matrix matstat = zeros(b.bootrep,1)
scalar nloop=1
scalar failed = 0
scalar failstop = 0.35
scalar cancel = 0
scalar btype = b.btype
loop while nloop &lt;= b.bootrep -q
  series e = 0
  drawE(&amp;b,&amp;e)
  # Simulate the null model (no long-run relationship)
  series y_b = zeromiss(0)
  varsimA(Y, b.rARcoef, Z, Xbeta, e, b.pq, &amp;y_b)
  lags y_b 1
  # Estimate the alt model based on the the null model DGP
  catch ols y_b lDET y_b(-1 to -b.pq) xlist(b.pqmin to -b.pq) rxlist --quiet
  if nelem($xlist)!=cols(Rmat) || (sum($coeff[b.ay:b.ey])-1)&gt;-0.00001
    failed++
    if failed/b.bootrep &gt;= b.failstop
      #printf &quot;*** ERROR: %d pct. of the bootstrap iterations failed due to instability. ***\n&quot;, 100*b.failstop
      printf &quot;*** You should re-consider to re-specify your model. ***\n&quot;
      cancel=1
      break
    endif
  else
    # Run the restriction of the estimated alt model based on null model dgp
    restrict --silent		 # H0: SUM(a_j)-1=0 --&gt; in ECM: rho=0
      R = Rmat
      q = qvec
    end restrict
    matstat[nloop] = $test
    nloop++
  endif
endloop
if quiet!=&quot;--quiet&quot;
  #printf &quot;\n*** NOTE: %.2f pct. of the %d bootstrap iterations failed due to instability. ***\n&quot;, 100*failed/b.bootrep, b.bootrep
  #printf &quot;\n&quot;
endif
b.cancel = cancel
if cancel==0
  b.failed = failed
  b.matstat = matstat
endif
# Clean up the bundle
delete b.ex
delete b.nrx
delete b.mx
delete b.nx
delete b.Rmat
delete b.Zcoef
delete b.qvec
delete b.ay
delete b.nall
delete b.ax
delete b.md
delete b.rARcoef
delete b.ey
delete b.uhat
delete b.mrx
</code>
</gretl-function>
<gretl-function name="varsimA" type="void" private="1">
 <params count="7">
  <param name="Y" type="series"/>
  <param name="ARbeta" type="matrix">
<description>Coeff. vector of Y</description>
  </param>
  <param name="X" type="list">
<description>rxlist ~ xlist of exogenous (-pmin to -p)</description>
  </param>
  <param name="Xbeta" type="matrix">
<description>coeff vector of Xs</description>
  </param>
  <param name="e" type="series">
<description>resampled</description>
  </param>
  <param name="p" type="int"/>
  <param name="ysim" type="seriesref"/>
 </params>
<code># Thankfully borrowed from Jack!
series m = lincomb(X, Xbeta)
scalar T = minr(rows({e})~rows({m}))
if p&gt;1
  matrix A = ARbeta' | (I(p-1) ~ 0)
else
  matrix A = ARbeta'
endif
matrix y0 = mreverse({Y}[1:p])'
matrix U = {e + m} ~ zeros(T, p-1)
matrix S = varsimul(A, U, y0)
S = S[,1]
if p&gt;1
  S = {Y}[1:p-1] | S
endif
series ysim = S
</code>
</gretl-function>
<gretl-function name="arstabA" type="void" private="1">
 <params count="2">
  <param name="ARcoef" type="matrix"/>
  <param name="error" type="scalarref"/>
 </params>
<code>if (sum(ARcoef)-1)&gt;-0.00001
  error=1
else
  error=0
endif
</code>
</gretl-function>
<gretl-function name="drawE" type="void" private="1">
 <params count="2">
  <param name="b" type="bundleref"/>
  <param name="e" type="seriesref"/>
 </params>
<code>series uhat = b.uhat
#uhat = uhat-mean(uhat)	# TODO: is re-centering needed here??
if b.btype==0
  series e = normal(0,sd(uhat))	# parametric bootstrap
elif b.btype==1
  series e = resample(uhat)		# draw from estimated residuals by resampling (may suffer from serial correl.)
elif b.btype==2						# wild uniform
  series e = resample(uhat) * uniform(0,1)
elif b.btype==3						# Use Rademacher distrib. instead of uniform(0,1)
  series Rad = uniform(0,1)
  Rad = -1*(Rad&lt;=0.5) + (Rad&gt;0.5)
  series e = resample(uhat) * Rad
elif b.btype==4						# block bootstrap
  series e = SB(b.uhat)
endif
</code>
</gretl-function>
<gretl-function name="SB" type="series" private="1">
 <params count="1">
  <param name="x" type="matrix"/>
 </params>
<code>#matrix x &quot;Data to be resampled&quot;
scalar n = rows(x)
if n == 0
  funcerr &quot;data input error, check data&quot;
endif
b = round(1.75*(n^(1/3)))	# mean block size to rule-of-thumb value
p = 1/b   					# probability of a new run
s = seq(1,n)'              	# sequence
u = 1 | (muniform(n-1,1) .&lt; p) # run starts
r = cum(u)                     # id of each run
nr = r[n]                      # how many runs ?
sub = selifr(r ~ s, u)         # starting row for each run
sub[,2] -= mrandgen(i, 1, n, nr, 1) # adjust starting points
# --- create mini-trends ----------------
s -= replace(r, sub[,1], sub[,2])
# roll over if necessary
s = ((s-1)%n) + 1
series xx = x[s,]
return xx
</code>
</gretl-function>
<sample-script>
set verbose off
clear 
include cointARDL.gfn --force
#include /home/at/git/cointARDL/cointARDL.gfn --force
#-----------
# Example 1
#-----------
open denmark.gdt -q

# Run the bootstrap version based on the ARDL
list xlist = LRY IBO #IDE
list rxlist = const
scalar pq = 2
scalar condARDL = 1			# 0=unconditional, 1=conditional ARDL
scalar case = 1				# 0=unrestr. const., 1=restrc. const., 2=restr. const + restr. trend
scalar btype = 4			# 0=parametric, 1=non-param, 2=wild, 3=wild+Rademacher distrib., 4=block-boot
scalar bootrep = 999			# no. of iterations
scalar failstop = 0.1		# max. fraction of unstable models
scalar which = 1			# 0=BDM, 1=PSS test
scalar verbose = 1			# 0=no details, 1=print details
# Setup the ARDL model: y(t) = b0 + b1*y(t-1) + b2*x(t) + b3*x(t-1) + u(t)
bundle b = setMod(which, case, LRM, xlist, rxlist, \
  pq, condARDL, btype, bootrep, failstop, verbose)
# Run bootstrap cointegration test
runCoint(&amp;b)

# Grab relevant information from bundle b
scalar cv5 = b.crit [2]
# 5 pct . bootstrap critical value
matrix bstats = b.matstat
# vector of bootstrap test statistics
matrix mplot = bstats ~( ones( rows( bstats ) ,1)* cv5 )~ seq(1 , rows( bstats ) ,) '
colnames(mplot ,&quot; Test - stats critval5 seq &quot;)
# attache column names
plot mplot
    options with-lines fit=none
end plot --output=display


/* Activate if needed
   #---------------------------------
   # Example 2 -- Simulation example
   #---------------------------------
   clear
   nulldata 200 --preserve
   setobs 1 1 --special-time-series
   scalar T = max(index)
   set seed 1234
   scalar m = 2            # Dimension of cov matrix
   matrix covm = I(m)      # Simple case: identity matrix
   covm[2,1]=0				# determine contemporanous correlation
   covm[1,2]=covm[2,1]
   matrix errmn = mnormal(T,cols(covm)) * cholesky(covm)' # drawnorm(covm,TT)
   #eval mcorr(errmn)
                    
   series e1 = errmn[,1]
   series e2 = errmn[,2]
   scalar delta = 0#.01					# drift param. for x-process
   series x = cum(delta+e1)				# DGP for x, simple RW(+drift)
   scalar a = 0			# intercept
   scalar phi = 0.9		# speed of adjustment param. rho=phi-1
   scalar c0 = 0.5			# contemporanous effect of x
   scalar c1 = -0.45		# 1st lag of x
   series y = 0			# init. value
   series y = a + phi*y(-1) + c0*x + c1*x(-1) + e2	# DGP: ARDL in levels
   printf &quot;\n************************************\n&quot;
   printf &quot;Error-correction param. = %.3f\n&quot;, (phi-1)
   printf &quot;LR-beta multiplier = %.3f\n&quot;, (c0+c1)/(phi-1)
   printf &quot;************************************\n&quot;

   smpl index &gt;= T/2 --restrict		# allow for burn-in phase
   store &quot;@dotdir/dtmp.gdt&quot;
   open &quot;@dotdir/dtmp.gdt&quot; -q
   gnuplot x y --with-lines --time-series --output=display
   # Run the bootstrap version based on the ARDL
   list xlist = x
   list rxlist = const time
   scalar pq = 1			# lag length in levels
   scalar condARDL = 1		# conditional ARDL: 0=NO, 1=YES
   scalar case = 2			# 0=unrestr. intercept, 1=rest. intercept, 2=restr. const+trend
   scalar btype = 1		# 0=parametric, 1=non-param, 2=wild, 3=wild+Rademacher distrib.
   scalar bootrep = 1999
   scalar failstop = 0.1	# max. percentage of failed stability
   scalar which = 0		# 0=BDM, 1=PSS test
   # Setup the model
   bundle B = setMod(which, case, y, xlist, rxlist, \
   pq, condARDL, btype, bootrep, failstop, 1)
   # Run bootstrap cointegration test
   runCoint(&amp;B)
   
   # Johansen test for comparison
   list endo = y x
   coint2 pq y x #--rc
*/
</sample-script>
</gretl-function-package>
</gretl-functions>
